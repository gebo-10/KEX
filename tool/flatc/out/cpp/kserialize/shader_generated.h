// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SHADER_KSERIALIZE_H_
#define FLATBUFFERS_GENERATED_SHADER_KSERIALIZE_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace kserialize {

struct Shader;
struct ShaderBuilder;
struct ShaderT;

inline const flatbuffers::TypeTable *ShaderTypeTable();

struct ShaderT : public flatbuffers::NativeTable {
  typedef Shader TableType;
  std::shared_ptr<kserialize::AssetCommon> asset_common{};
  std::string vert{};
  std::string frag{};
};

struct Shader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShaderT NativeTableType;
  typedef ShaderBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ShaderTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ASSET_COMMON = 4,
    VT_VERT = 6,
    VT_FRAG = 8
  };
  const kserialize::AssetCommon *asset_common() const {
    return GetStruct<const kserialize::AssetCommon *>(VT_ASSET_COMMON);
  }
  const flatbuffers::String *vert() const {
    return GetPointer<const flatbuffers::String *>(VT_VERT);
  }
  const flatbuffers::String *frag() const {
    return GetPointer<const flatbuffers::String *>(VT_FRAG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<kserialize::AssetCommon>(verifier, VT_ASSET_COMMON) &&
           VerifyOffset(verifier, VT_VERT) &&
           verifier.VerifyString(vert()) &&
           VerifyOffset(verifier, VT_FRAG) &&
           verifier.VerifyString(frag()) &&
           verifier.EndTable();
  }
  ShaderT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShaderT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Shader> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShaderT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShaderBuilder {
  typedef Shader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_asset_common(const kserialize::AssetCommon *asset_common) {
    fbb_.AddStruct(Shader::VT_ASSET_COMMON, asset_common);
  }
  void add_vert(flatbuffers::Offset<flatbuffers::String> vert) {
    fbb_.AddOffset(Shader::VT_VERT, vert);
  }
  void add_frag(flatbuffers::Offset<flatbuffers::String> frag) {
    fbb_.AddOffset(Shader::VT_FRAG, frag);
  }
  explicit ShaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Shader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Shader>(end);
    return o;
  }
};

inline flatbuffers::Offset<Shader> CreateShader(
    flatbuffers::FlatBufferBuilder &_fbb,
    const kserialize::AssetCommon *asset_common = 0,
    flatbuffers::Offset<flatbuffers::String> vert = 0,
    flatbuffers::Offset<flatbuffers::String> frag = 0) {
  ShaderBuilder builder_(_fbb);
  builder_.add_frag(frag);
  builder_.add_vert(vert);
  builder_.add_asset_common(asset_common);
  return builder_.Finish();
}

struct Shader::Traits {
  using type = Shader;
  static auto constexpr Create = CreateShader;
};

inline flatbuffers::Offset<Shader> CreateShaderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const kserialize::AssetCommon *asset_common = 0,
    const char *vert = nullptr,
    const char *frag = nullptr) {
  auto vert__ = vert ? _fbb.CreateString(vert) : 0;
  auto frag__ = frag ? _fbb.CreateString(frag) : 0;
  return kserialize::CreateShader(
      _fbb,
      asset_common,
      vert__,
      frag__);
}

flatbuffers::Offset<Shader> CreateShader(flatbuffers::FlatBufferBuilder &_fbb, const ShaderT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ShaderT *Shader::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ShaderT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Shader::UnPackTo(ShaderT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = asset_common(); if (_e) _o->asset_common = std::shared_ptr<kserialize::AssetCommon>(new kserialize::AssetCommon(*_e)); }
  { auto _e = vert(); if (_e) _o->vert = _e->str(); }
  { auto _e = frag(); if (_e) _o->frag = _e->str(); }
}

inline flatbuffers::Offset<Shader> Shader::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShaderT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShader(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Shader> CreateShader(flatbuffers::FlatBufferBuilder &_fbb, const ShaderT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShaderT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _asset_common = _o->asset_common ? _o->asset_common.get() : 0;
  auto _vert = _o->vert.empty() ? 0 : _fbb.CreateString(_o->vert);
  auto _frag = _o->frag.empty() ? 0 : _fbb.CreateString(_o->frag);
  return kserialize::CreateShader(
      _fbb,
      _asset_common,
      _vert,
      _frag);
}

inline const flatbuffers::TypeTable *ShaderTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    kserialize::AssetCommonTypeTable
  };
  static const char * const names[] = {
    "asset_common",
    "vert",
    "frag"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const kserialize::Shader *GetShader(const void *buf) {
  return flatbuffers::GetRoot<kserialize::Shader>(buf);
}

inline const kserialize::Shader *GetSizePrefixedShader(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<kserialize::Shader>(buf);
}

inline bool VerifyShaderBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<kserialize::Shader>(nullptr);
}

inline bool VerifySizePrefixedShaderBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<kserialize::Shader>(nullptr);
}

inline void FinishShaderBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<kserialize::Shader> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedShaderBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<kserialize::Shader> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::shared_ptr<kserialize::ShaderT> UnPackShader(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::shared_ptr<kserialize::ShaderT>(GetShader(buf)->UnPack(res));
}

inline std::shared_ptr<kserialize::ShaderT> UnPackSizePrefixedShader(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::shared_ptr<kserialize::ShaderT>(GetSizePrefixedShader(buf)->UnPack(res));
}

}  // namespace kserialize

#endif  // FLATBUFFERS_GENERATED_SHADER_KSERIALIZE_H_
