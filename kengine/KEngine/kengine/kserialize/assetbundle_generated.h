// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ASSETBUNDLE_KSERIALIZE_H_
#define FLATBUFFERS_GENERATED_ASSETBUNDLE_KSERIALIZE_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace kserialize {

struct AssetInfo;
struct AssetInfoBuilder;
struct AssetInfoT;

struct AssetBundle;
struct AssetBundleBuilder;
struct AssetBundleT;

inline const flatbuffers::TypeTable *AssetInfoTypeTable();

inline const flatbuffers::TypeTable *AssetBundleTypeTable();

struct AssetInfoT : public flatbuffers::NativeTable {
  typedef AssetInfo TableType;
  kserialize::AssetType type = kserialize::AssetType::Texture;
  uint32_t id = 0;
  uint32_t offset = 0;
  uint32_t size = 0;
  std::vector<uint32_t> depends{};
};

struct AssetInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssetInfoT NativeTableType;
  typedef AssetInfoBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AssetInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ID = 6,
    VT_OFFSET = 8,
    VT_SIZE = 10,
    VT_DEPENDS = 12
  };
  kserialize::AssetType type() const {
    return static_cast<kserialize::AssetType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  const flatbuffers::Vector<uint32_t> *depends() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DEPENDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET) &&
           VerifyField<uint32_t>(verifier, VT_SIZE) &&
           VerifyOffset(verifier, VT_DEPENDS) &&
           verifier.VerifyVector(depends()) &&
           verifier.EndTable();
  }
  AssetInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AssetInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AssetInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssetInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AssetInfoBuilder {
  typedef AssetInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(kserialize::AssetType type) {
    fbb_.AddElement<int8_t>(AssetInfo::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(AssetInfo::VT_ID, id, 0);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(AssetInfo::VT_OFFSET, offset, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(AssetInfo::VT_SIZE, size, 0);
  }
  void add_depends(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> depends) {
    fbb_.AddOffset(AssetInfo::VT_DEPENDS, depends);
  }
  explicit AssetInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AssetInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssetInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssetInfo> CreateAssetInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    kserialize::AssetType type = kserialize::AssetType::Texture,
    uint32_t id = 0,
    uint32_t offset = 0,
    uint32_t size = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> depends = 0) {
  AssetInfoBuilder builder_(_fbb);
  builder_.add_depends(depends);
  builder_.add_size(size);
  builder_.add_offset(offset);
  builder_.add_id(id);
  builder_.add_type(type);
  return builder_.Finish();
}

struct AssetInfo::Traits {
  using type = AssetInfo;
  static auto constexpr Create = CreateAssetInfo;
};

inline flatbuffers::Offset<AssetInfo> CreateAssetInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    kserialize::AssetType type = kserialize::AssetType::Texture,
    uint32_t id = 0,
    uint32_t offset = 0,
    uint32_t size = 0,
    const std::vector<uint32_t> *depends = nullptr) {
  auto depends__ = depends ? _fbb.CreateVector<uint32_t>(*depends) : 0;
  return kserialize::CreateAssetInfo(
      _fbb,
      type,
      id,
      offset,
      size,
      depends__);
}

flatbuffers::Offset<AssetInfo> CreateAssetInfo(flatbuffers::FlatBufferBuilder &_fbb, const AssetInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AssetBundleT : public flatbuffers::NativeTable {
  typedef AssetBundle TableType;
  uint32_t id = 0;
  std::vector<std::shared_ptr<kserialize::AssetInfoT>> asset_infos{};
};

struct AssetBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssetBundleT NativeTableType;
  typedef AssetBundleBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AssetBundleTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ASSET_INFOS = 6
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<kserialize::AssetInfo>> *asset_infos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<kserialize::AssetInfo>> *>(VT_ASSET_INFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_ASSET_INFOS) &&
           verifier.VerifyVector(asset_infos()) &&
           verifier.VerifyVectorOfTables(asset_infos()) &&
           verifier.EndTable();
  }
  AssetBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AssetBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AssetBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssetBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AssetBundleBuilder {
  typedef AssetBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(AssetBundle::VT_ID, id, 0);
  }
  void add_asset_infos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<kserialize::AssetInfo>>> asset_infos) {
    fbb_.AddOffset(AssetBundle::VT_ASSET_INFOS, asset_infos);
  }
  explicit AssetBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AssetBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssetBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssetBundle> CreateAssetBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<kserialize::AssetInfo>>> asset_infos = 0) {
  AssetBundleBuilder builder_(_fbb);
  builder_.add_asset_infos(asset_infos);
  builder_.add_id(id);
  return builder_.Finish();
}

struct AssetBundle::Traits {
  using type = AssetBundle;
  static auto constexpr Create = CreateAssetBundle;
};

inline flatbuffers::Offset<AssetBundle> CreateAssetBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const std::vector<flatbuffers::Offset<kserialize::AssetInfo>> *asset_infos = nullptr) {
  auto asset_infos__ = asset_infos ? _fbb.CreateVector<flatbuffers::Offset<kserialize::AssetInfo>>(*asset_infos) : 0;
  return kserialize::CreateAssetBundle(
      _fbb,
      id,
      asset_infos__);
}

flatbuffers::Offset<AssetBundle> CreateAssetBundle(flatbuffers::FlatBufferBuilder &_fbb, const AssetBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline AssetInfoT *AssetInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<AssetInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AssetInfo::UnPackTo(AssetInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = id(); _o->id = _e; }
  { auto _e = offset(); _o->offset = _e; }
  { auto _e = size(); _o->size = _e; }
  { auto _e = depends(); if (_e) { _o->depends.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->depends[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<AssetInfo> AssetInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssetInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAssetInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AssetInfo> CreateAssetInfo(flatbuffers::FlatBufferBuilder &_fbb, const AssetInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AssetInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _id = _o->id;
  auto _offset = _o->offset;
  auto _size = _o->size;
  auto _depends = _o->depends.size() ? _fbb.CreateVector(_o->depends) : 0;
  return kserialize::CreateAssetInfo(
      _fbb,
      _type,
      _id,
      _offset,
      _size,
      _depends);
}

inline AssetBundleT *AssetBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<AssetBundleT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AssetBundle::UnPackTo(AssetBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = asset_infos(); if (_e) { _o->asset_infos.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->asset_infos[_i] = std::shared_ptr<kserialize::AssetInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<AssetBundle> AssetBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssetBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAssetBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AssetBundle> CreateAssetBundle(flatbuffers::FlatBufferBuilder &_fbb, const AssetBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AssetBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _asset_infos = _o->asset_infos.size() ? _fbb.CreateVector<flatbuffers::Offset<kserialize::AssetInfo>> (_o->asset_infos.size(), [](size_t i, _VectorArgs *__va) { return CreateAssetInfo(*__va->__fbb, __va->__o->asset_infos[i].get(), __va->__rehasher); }, &_va ) : 0;
  return kserialize::CreateAssetBundle(
      _fbb,
      _id,
      _asset_infos);
}

inline const flatbuffers::TypeTable *AssetInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    kserialize::AssetTypeTypeTable
  };
  static const char * const names[] = {
    "type",
    "id",
    "offset",
    "size",
    "depends"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AssetBundleTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    kserialize::AssetInfoTypeTable
  };
  static const char * const names[] = {
    "id",
    "asset_infos"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const kserialize::AssetBundle *GetAssetBundle(const void *buf) {
  return flatbuffers::GetRoot<kserialize::AssetBundle>(buf);
}

inline const kserialize::AssetBundle *GetSizePrefixedAssetBundle(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<kserialize::AssetBundle>(buf);
}

inline bool VerifyAssetBundleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<kserialize::AssetBundle>(nullptr);
}

inline bool VerifySizePrefixedAssetBundleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<kserialize::AssetBundle>(nullptr);
}

inline void FinishAssetBundleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<kserialize::AssetBundle> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedAssetBundleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<kserialize::AssetBundle> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::shared_ptr<kserialize::AssetBundleT> UnPackAssetBundle(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::shared_ptr<kserialize::AssetBundleT>(GetAssetBundle(buf)->UnPack(res));
}

inline std::shared_ptr<kserialize::AssetBundleT> UnPackSizePrefixedAssetBundle(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::shared_ptr<kserialize::AssetBundleT>(GetSizePrefixedAssetBundle(buf)->UnPack(res));
}

}  // namespace kserialize

#endif  // FLATBUFFERS_GENERATED_ASSETBUNDLE_KSERIALIZE_H_
