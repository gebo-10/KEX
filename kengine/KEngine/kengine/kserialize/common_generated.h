// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMON_KSERIALIZE_H_
#define FLATBUFFERS_GENERATED_COMMON_KSERIALIZE_H_

#include "flatbuffers/flatbuffers.h"

namespace kserialize {

struct Vec2;

struct Vec3;

struct Vec4;

struct RGB;

struct RGBA;

struct AssetCommon;

inline const flatbuffers::TypeTable *Vec2TypeTable();

inline const flatbuffers::TypeTable *Vec3TypeTable();

inline const flatbuffers::TypeTable *Vec4TypeTable();

inline const flatbuffers::TypeTable *RGBTypeTable();

inline const flatbuffers::TypeTable *RGBATypeTable();

inline const flatbuffers::TypeTable *AssetCommonTypeTable();

enum class AssetType : int8_t {
  Texture = 0,
  Shader = 1,
  Material = 2,
  Mesh = 3,
  Model = 4,
  Prefab = 5,
  MIN = Texture,
  MAX = Prefab
};

inline const AssetType (&EnumValuesAssetType())[6] {
  static const AssetType values[] = {
    AssetType::Texture,
    AssetType::Shader,
    AssetType::Material,
    AssetType::Mesh,
    AssetType::Model,
    AssetType::Prefab
  };
  return values;
}

inline const char * const *EnumNamesAssetType() {
  static const char * const names[7] = {
    "Texture",
    "Shader",
    "Material",
    "Mesh",
    "Model",
    "Prefab",
    nullptr
  };
  return names;
}

inline const char *EnumNameAssetType(AssetType e) {
  if (flatbuffers::IsOutRange(e, AssetType::Texture, AssetType::Prefab)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAssetType()[index];
}

enum class MemeryType : int8_t {
  RAM = 0,
  GPU = 1,
  RAMGPU = 2,
  MIN = RAM,
  MAX = RAMGPU
};

inline const MemeryType (&EnumValuesMemeryType())[3] {
  static const MemeryType values[] = {
    MemeryType::RAM,
    MemeryType::GPU,
    MemeryType::RAMGPU
  };
  return values;
}

inline const char * const *EnumNamesMemeryType() {
  static const char * const names[4] = {
    "RAM",
    "GPU",
    "RAMGPU",
    nullptr
  };
  return names;
}

inline const char *EnumNameMemeryType(MemeryType e) {
  if (flatbuffers::IsOutRange(e, MemeryType::RAM, MemeryType::RAMGPU)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMemeryType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vec2TypeTable();
  }
  Vec2()
      : x_(0),
        y_(0) {
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

struct Vec2::Traits {
  using type = Vec2;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vec3TypeTable();
  }
  Vec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

struct Vec3::Traits {
  using type = Vec3;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vec4TypeTable();
  }
  Vec4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

struct Vec4::Traits {
  using type = Vec4;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) RGB FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;

 public:
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RGBTypeTable();
  }
  RGB()
      : r_(0),
        g_(0),
        b_(0) {
  }
  RGB(uint8_t _r, uint8_t _g, uint8_t _b)
      : r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)) {
  }
  uint8_t r() const {
    return flatbuffers::EndianScalar(r_);
  }
  uint8_t g() const {
    return flatbuffers::EndianScalar(g_);
  }
  uint8_t b() const {
    return flatbuffers::EndianScalar(b_);
  }
};
FLATBUFFERS_STRUCT_END(RGB, 3);

struct RGB::Traits {
  using type = RGB;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) RGBA FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;
  uint8_t a_;

 public:
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RGBATypeTable();
  }
  RGBA()
      : r_(0),
        g_(0),
        b_(0),
        a_(0) {
  }
  RGBA(uint8_t _r, uint8_t _g, uint8_t _b, uint8_t _a)
      : r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)),
        a_(flatbuffers::EndianScalar(_a)) {
  }
  uint8_t r() const {
    return flatbuffers::EndianScalar(r_);
  }
  uint8_t g() const {
    return flatbuffers::EndianScalar(g_);
  }
  uint8_t b() const {
    return flatbuffers::EndianScalar(b_);
  }
  uint8_t a() const {
    return flatbuffers::EndianScalar(a_);
  }
};
FLATBUFFERS_STRUCT_END(RGBA, 4);

struct RGBA::Traits {
  using type = RGBA;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) AssetCommon FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t id_;
  int8_t asset_type_;
  int8_t memery_type_;
  int16_t padding0__;

 public:
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AssetCommonTypeTable();
  }
  AssetCommon()
      : id_(0),
        asset_type_(0),
        memery_type_(0),
        padding0__(0) {
    (void)padding0__;
  }
  AssetCommon(uint32_t _id, kserialize::AssetType _asset_type, kserialize::MemeryType _memery_type)
      : id_(flatbuffers::EndianScalar(_id)),
        asset_type_(flatbuffers::EndianScalar(static_cast<int8_t>(_asset_type))),
        memery_type_(flatbuffers::EndianScalar(static_cast<int8_t>(_memery_type))),
        padding0__(0) {
    (void)padding0__;
  }
  uint32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
  kserialize::AssetType asset_type() const {
    return static_cast<kserialize::AssetType>(flatbuffers::EndianScalar(asset_type_));
  }
  kserialize::MemeryType memery_type() const {
    return static_cast<kserialize::MemeryType>(flatbuffers::EndianScalar(memery_type_));
  }
};
FLATBUFFERS_STRUCT_END(AssetCommon, 8);

struct AssetCommon::Traits {
  using type = AssetCommon;
};

inline const flatbuffers::TypeTable *AssetTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    kserialize::AssetTypeTypeTable
  };
  static const char * const names[] = {
    "Texture",
    "Shader",
    "Material",
    "Mesh",
    "Model",
    "Prefab"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MemeryTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    kserialize::MemeryTypeTypeTable
  };
  static const char * const names[] = {
    "RAM",
    "GPU",
    "RAMGPU"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Vec2TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8 };
  static const char * const names[] = {
    "x",
    "y"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 2, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Vec3TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8, 12 };
  static const char * const names[] = {
    "x",
    "y",
    "z"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 3, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Vec4TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8, 12, 16 };
  static const char * const names[] = {
    "x",
    "y",
    "z",
    "w"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 4, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RGBTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const int64_t values[] = { 0, 1, 2, 3 };
  static const char * const names[] = {
    "r",
    "g",
    "b"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 3, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RGBATypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const int64_t values[] = { 0, 1, 2, 3, 4 };
  static const char * const names[] = {
    "r",
    "g",
    "b",
    "a"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 4, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AssetCommonTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    kserialize::AssetTypeTypeTable,
    kserialize::MemeryTypeTypeTable
  };
  static const int64_t values[] = { 0, 4, 5, 8 };
  static const char * const names[] = {
    "id",
    "asset_type",
    "memery_type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 3, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

}  // namespace kserialize

#endif  // FLATBUFFERS_GENERATED_COMMON_KSERIALIZE_H_
